/*
* Camera update on resize (= window resize event in Application)
* Fix bug where sometimes the framerate doesn't match the refresh rate (In other words, vsync doesn't work)
* Support rendering multiple vertex buffers
  - Maybe renderer.add(Pipeline* pipeline) for each render call.
* Support smooth resizing (See quote from CharlesG)
* Textures (https://vulkan-tutorial.com/Texture_mapping/Images)
* F11 Fullscreen keybind
* Make application close gracefully if an exception is thrown
* Check out this: https://renderdoc.org/ (Graphics debugger)
*/


CharlesG â€” Yesterday at 17:45
================================
The gist of a smooth swapchain resizing is to remove vkDeviceWaitIdle / vkQueueWaitIdle
How do you do that? Pipeline the crap out of everything and delay destruction of everything until they are no longer in use.
First (if you haven't already), you will need to enable dynamic viewport/scissor in all your pipelines so you don't have to recreate your pipelines.
Then you need to make use of command buffer recording, so that you aren't trying to recreate 2-3 command buffers on resize. This makes it so you can easily 'change' which swapchain image you render to when recording your draw calls.
Also dont recreate the renderpass, that doesn't need recreation at all.
Now you can create the new swapchain, acquire image, create image views, and create framebuffers. 
Make sure the old swapchain is in the oldSwapchain parameter when you create the new one. This helps recycle resources.
Now you need to make it so the old swapchain, image views, and framebuffers don't get destroyed until they are done being rendered from.
So when you resize, you throw the old resources in a 'delayed destruction queue'. You check this queue every frame to determine if its actually complete, and only then do you destroy everything. 
This is the gist of it, I might of missed some detail about how to do it.